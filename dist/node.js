!function(e,r){if("object"==typeof exports&&"object"==typeof module)module.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{var t=r();for(var o in t)("object"==typeof exports?exports:e)[o]=t[o]}}(global,(function(){return(()=>{"use strict";var e,r,t={63:e=>{e.exports=require("@emurgo/cardano-serialization-lib-browser")},111:e=>{e.exports=require("@emurgo/cardano-serialization-lib-nodejs")},700:e=>{e.exports=require("emurgo-message-signing")},216:e=>{e.exports=require("emurgo-message-signing-nodejs")}},o={};function n(e){var r=o[e];if(void 0!==r)return r.exports;var s=o[e]={exports:{}};return t[e](s,s.exports,n),s.exports}n.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return n.d(r,{a:r}),r},r=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,n.t=function(t,o){if(1&o&&(t=this(t)),8&o)return t;if("object"==typeof t&&t){if(4&o&&t.__esModule)return t;if(16&o&&"function"==typeof t.then)return t}var s=Object.create(null);n.r(s);var a={};e=e||[null,r({}),r([]),r(r)];for(var i=2&o&&t;"object"==typeof i&&!~e.indexOf(i);i=r(i))Object.getOwnPropertyNames(i).forEach((e=>a[e]=()=>t[e]));return a.default=()=>t,n.d(s,a),s},n.d=(e,r)=>{for(var t in r)n.o(r,t)&&!n.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},n.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var s={};return(()=>{n.d(s,{default:()=>u});const e=require("base-64");var r=n.n(e);const t=require("ms");var o=n.n(t);const a=require("parse-headers");var i=n.n(a);const d=require("buffer"),f=new class{async load(){this._wasm&&this._wasm2||(this.isBrowser="undefined"!=typeof window,this._wasm=this.isBrowser?await Promise.resolve().then(n.t.bind(n,63,23)):await Promise.resolve().then(n.t.bind(n,111,23)),this._wasm2=this.isBrowser?await Promise.resolve().then(n.t.bind(n,700,23)):await Promise.resolve().then(n.t.bind(n,216,23)))}get Cardano(){return this._wasm}get Message(){return this._wasm2}},u={sign:async(e,t="1d",n={})=>{const s=(e=>{const r='"expires_in" argument should be a number of milliseconds or a string representing a timespan eg: "1d", "20h", 60';if("string"==typeof e){const t=o()(e);if(void 0===t)throw new Error(r);return new Date(Date.now()+t).toUTCString()}if("number"==typeof e)return new Date(Date.now()+e).toUTCString();throw new Error(r)})(t);(e=>{for(const r in e){const t=e[r];if("Expire-Date"===r)throw new Error('Please do not rewrite "Expire-Date" field');if("Web3-Token-Version"===r)throw new Error('Please do not rewrite "Web3-Token-Version" field');if("string"!=typeof t)throw new Error("Body can only contain string values")}})(n);const a=(e=>{const r=[];for(const t in e)r.push(`${t}: ${e[t]}`);return r.join("\n")})({"Web3-Token-Version":1,"Expire-Date":s,...n});if("function"!=typeof e)throw new Error('"signer" argument should be a function that returns a signature eg: "msg => web3.eth.personal.sign(msg, <YOUR_ADDRESS>)"');var i=await e(a);const{signature:d,key:f}=i;if("string"!=typeof d)throw new Error('"signer" argument should be a function that returns a signature string (Promise<string>)');return r().encode(JSON.stringify({signature:d,key:f,body:a}))},verify:async e=>{if(!e||!e.length)throw new Error("Token required.");try{var t=r().decode(e)}catch(e){throw new Error("Token malformed (must be base64 encoded)")}if(!t||!t.length)throw new Error("Token malformed (must be base64 encoded)");try{var{body:o,signature:n,key:s}=JSON.parse(t)}catch(e){throw new Error("Token malformed (unparsable JSON)")}if(!o||!o.length)throw new Error("Token malformed (empty message)");if(!n||!n.length)throw new Error("Token malformed (empty signature)");await f.load();const a=f.Message.COSESign1.from_bytes(d.Buffer.from(d.Buffer.from(n,"hex"),"hex")),u=a.headers().protected().deserialized_headers(),c=f.Cardano.Address.from_bytes(u.header(f.Message.Label.new_text("address")).as_bytes()),g=f.Message.COSEKey.from_bytes(d.Buffer.from(s,"hex")),h=f.Cardano.PublicKey.from_bytes(g.header(f.Message.Label.new_int(f.Message.Int.new_negative(f.Message.BigNum.from_str("2")))).as_bytes()),m=function(e,r){console.log("In Verify Address");const t=f.Cardano.BaseAddress.from_address(e);try{const o=r.hash(),n=t.stake_cred().to_keyhash(),s=f.Cardano.BaseAddress.new(e.network_id(),f.Cardano.StakeCredential.from_keyhash(o),f.Cardano.StakeCredential.from_keyhash(n));return e.to_bech32()!==s.to_address().to_bech32()?{verified:!1,code:1,message:"Check address does not match Reconstructed Address (Public Key is not the correct key for this Address)"}:{verified:!0}}catch(e){return{verified:!1,code:3,message:e.message}}}(c,h);if(!m.verified)throw new Error(`Address verification failed: (${m.message} (${m.code}))`);const l=a.signed_data().to_bytes(),w=d.Buffer.from(l).toString("utf-8"),y=f.Cardano.Ed25519Signature.from_bytes(a.signature());if(!h.verify(l,y))throw new Error("Message integrity check failed (has the message been tampered with?)");const b=i()(w);if(b["expire-date"]&&new Date(b["expire-date"])<new Date)throw new Error("Token expired");return{address:c.to_bech32(),network:c.network_id(),body:b}}}})(),s.default})()}));