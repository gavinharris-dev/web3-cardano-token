!function(e,r){if("object"==typeof exports&&"object"==typeof module)module.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{var t=r();for(var o in t)("object"==typeof exports?exports:e)[o]=t[o]}}(global,(function(){return(()=>{"use strict";var e,r,t={63:e=>{e.exports=require("@emurgo/cardano-serialization-lib-browser")},111:e=>{e.exports=require("@emurgo/cardano-serialization-lib-nodejs")},700:e=>{e.exports=require("emurgo-message-signing")},216:e=>{e.exports=require("emurgo-message-signing-nodejs")}},o={};function s(e){var r=o[e];if(void 0!==r)return r.exports;var n=o[e]={exports:{}};return t[e](n,n.exports,s),n.exports}s.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return s.d(r,{a:r}),r},r=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,s.t=function(t,o){if(1&o&&(t=this(t)),8&o)return t;if("object"==typeof t&&t){if(4&o&&t.__esModule)return t;if(16&o&&"function"==typeof t.then)return t}var n=Object.create(null);s.r(n);var a={};e=e||[null,r({}),r([]),r(r)];for(var i=2&o&&t;"object"==typeof i&&!~e.indexOf(i);i=r(i))Object.getOwnPropertyNames(i).forEach((e=>a[e]=()=>t[e]));return a.default=()=>t,s.d(n,a),n},s.d=(e,r)=>{for(var t in r)s.o(r,t)&&!s.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:r[t]})},s.o=(e,r)=>Object.prototype.hasOwnProperty.call(e,r),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{s.d(n,{default:()=>g});const e=require("base-64");var r=s.n(e);const t=require("ms");var o=s.n(t);const a=require("parse-headers");var i=s.n(a);const d=require("buffer"),f=new class{async load(){this._wasm&&this._wasm2||(this.isBrowser="undefined"!=typeof window,this._wasm=this.isBrowser?await Promise.resolve().then(s.t.bind(s,63,23)):await Promise.resolve().then(s.t.bind(s,111,23)),this._wasm2=this.isBrowser?await Promise.resolve().then(s.t.bind(s,700,23)):await Promise.resolve().then(s.t.bind(s,216,23)))}get Cardano(){return this._wasm}get Message(){return this._wasm2}},u=!!process.env.DEBUG_WEB3;function c(e,...r){u&&console.log(e,r)}const g={sign:async(e,t="1d",s={})=>{const n=(e=>{const r='"expires_in" argument should be a number of milliseconds or a string representing a timespan eg: "1d", "20h", 60';if("string"==typeof e){const t=o()(e);if(void 0===t)throw new Error(r);return new Date(Date.now()+t).toUTCString()}if("number"==typeof e)return new Date(Date.now()+e).toUTCString();throw new Error(r)})(t);(e=>{for(const r in e){const t=e[r];if("Expire-Date"===r)throw new Error('Please do not rewrite "Expire-Date" field');if("Web3-Token-Version"===r)throw new Error('Please do not rewrite "Web3-Token-Version" field');if("string"!=typeof t)throw new Error("Body can only contain string values")}})(s);const a=(e=>{const r=[];for(const t in e)r.push(`${t}: ${e[t]}`);return r.join("\n")})({"Web3-Token-Version":1,"Expire-Date":n,...s});if("function"!=typeof e)throw new Error('"signer" argument should be a function that returns a signature eg: "msg => web3.eth.personal.sign(msg, <YOUR_ADDRESS>)"');var i=await e(a);const{signature:d,key:f}=i;if("string"!=typeof d)throw new Error('"signature" argument should be a function that returns a signature string (Promise<string>)');return r().encode(JSON.stringify({signature:d,key:f,body:a}))},verify:async e=>{if(!e||!e.length)throw new Error("Token required.");try{var t=r().decode(e)}catch(e){throw new Error("Token malformed (must be base64 encoded)")}if(!t||!t.length)throw new Error("Token malformed (must be base64 encoded)");try{var{body:o,signature:s,key:n}=JSON.parse(t)}catch(e){throw new Error("Token malformed (unparsable JSON)")}if(!o||!o.length)throw new Error("Token malformed (empty message)");if(!s||!s.length)throw new Error("Token malformed (empty signature)");await f.load();const a=f.Message.COSESign1.from_bytes(d.Buffer.from(d.Buffer.from(s,"hex"),"hex"));c("message",a);const u=a.headers().protected().deserialized_headers(),g=f.Cardano.Address.from_bytes(u.header(f.Message.Label.new_text("address")).as_bytes()),l=f.Message.COSEKey.from_bytes(d.Buffer.from(n,"hex")),h=f.Cardano.PublicKey.from_bytes(l.header(f.Message.Label.new_int(f.Message.Int.new_negative(f.Message.BigNum.from_str("2")))).as_bytes());c("publicKey",d.Buffer.from(h.as_bytes()).toString("hex"));const m=((e,r)=>{c("In verifyAddress",e,r);let t="";try{c("Step verifyAddress",1);const t=r.hash();c("Step verifyAddress",2);const o=f.Cardano.BaseAddress.from_address(e).stake_cred().to_keyhash();c("Step verifyAddress",3);const s=f.Cardano.BaseAddress.new(e.network_id(),f.Cardano.StakeCredential.from_keyhash(t),f.Cardano.StakeCredential.from_keyhash(o));c("Step verifyAddress",4);const n=e.to_bech32()===s.to_address().to_bech32();return c("Step verifyAddress",5,n),{status:n,msg:n?"Valid Address":"Base Address does not validate to Reconstructed address",code:1}}catch(e){c("Err verifyAddress",e),t+=` ${e.message}`}return{status:!1,msg:`Error: ${t}`,code:3}})(g,h);if(!m.status)throw new Error(`Address verification failed: (${m.message} (${m.code}))`);const w=a.signed_data().to_bytes(),y=d.Buffer.from(w).toString("utf-8"),b=f.Cardano.Ed25519Signature.from_bytes(a.signature());if(!h.verify(w,b))throw new Error("Message integrity check failed (has the message been tampered with?)");const p=i()(y);if(p["expire-date"]&&new Date(p["expire-date"])<new Date)throw new Error("Token expired");return{address:g.to_bech32(),network:g.network_id(),body:p}}}})(),n.default})()}));